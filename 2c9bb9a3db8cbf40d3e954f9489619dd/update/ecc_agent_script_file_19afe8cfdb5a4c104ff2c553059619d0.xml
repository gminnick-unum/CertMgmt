<?xml version="1.0" encoding="UTF-8"?><record_update sys_domain="global" table="ecc_agent_script_file">
    <ecc_agent_script_file action="INSERT_OR_UPDATE">
        <active>true</active>
        <checksum>u1DtADq3ku4ziFZydGWOOA==</checksum>
        <description>Process Tenable Scan Report </description>
        <directory>false</directory>
        <name>processTenableScanReport.ps1</name>
        <parent display_value="PowerShell">ef89e4fc372001006b882d465abe5d60</parent>
        <script>	#region input variables&#13;
	if (Test-Path env:\SNC_fileInputPath) {&#13;
		$fileInputFullPath = $env:SNC_fileInputFullPath&#13;
		$userName = $env:SNC_userName&#13;
		$userDomain = $env:SNC_userDomain&#13;
		$userPass = $env:SNC_userPass&#13;
		}        &#13;
    #endregion&#13;
&#13;
	&#13;
#region Impersonation&#13;
function Set-Impersonation&#13;
{&#13;
	Param(&#13;
	    [Parameter(ParameterSetName="ClearText", Mandatory=$true)][string]$Username,&#13;
	    [Parameter(ParameterSetName="ClearText", Mandatory=$true)][string]$Domain,&#13;
	    [Parameter(ParameterSetName="ClearText", Mandatory=$true)][string]$Password,&#13;
	    [Parameter(ParameterSetName="Credential", Mandatory=$true, Position=0)][PSCredential]$Credential,&#13;
	    [Parameter()][Switch]$Quiet&#13;
	)&#13;
&#13;
#Import the LogonUser Function from advapi32.dll and the CloseHandle Function from kernel32.dll&#13;
Add-Type -Namespace Import -Name Win32 -MemberDefinition @'&#13;
    [DllImport("advapi32.dll", SetLastError = true)]&#13;
    public static extern bool LogonUser(string user, string domain, string password, int logonType, int logonProvider, out IntPtr token);&#13;
&#13;
    [DllImport("kernel32.dll", SetLastError = true)]&#13;
    public static extern bool CloseHandle(IntPtr handle);&#13;
'@&#13;
&#13;
#Set Global variable to hold the Impersonation after it is created so it may be ended after script run&#13;
$Global:ImpersonatedUser = @{}&#13;
#Initialize handle variable so that it exists to be referenced in the LogonUser method&#13;
$tokenHandle = 0&#13;
&#13;
#Pass the PSCredentials to the variables to be sent to the LogonUser method&#13;
if ($Credential) {&#13;
    Get-Variable Username, Domain, Password | ForEach-Object {&#13;
        Set-Variable $_.Name -Value $Credential.GetNetworkCredential().$($_.Name)}&#13;
}&#13;
&#13;
#Call LogonUser and store its success.  [ref]$tokenHandle is used to store the token "out IntPtr token" from LogonUser.&#13;
$returnValue = [Import.Win32]::LogonUser($Username, $Domain, $Password, 2, 0, [ref]$tokenHandle)&#13;
&#13;
#If it fails, throw the verbose with the error code&#13;
if (!$returnValue) {&#13;
    $errCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error();&#13;
	if (!$Quiet) {&#13;
    	Write-Host "Impersonate-User failed a call to LogonUser with error code: $errCode"&#13;
	}&#13;
    throw [System.ComponentModel.Win32Exception]$errCode&#13;
}&#13;
#Successful token stored in $tokenHandle&#13;
else {&#13;
    #Call the Impersonate method with the returned token. An ImpersonationContext is returned and stored in the&#13;
    #Global variable so that it may be used after script run.&#13;
    $Global:ImpersonatedUser.ImpersonationContext = [System.Security.Principal.WindowsIdentity]::Impersonate($tokenHandle)&#13;
    &#13;
    #Close the handle to the token. Voided to mask the Boolean return value.&#13;
    [void][Import.Win32]::CloseHandle($tokenHandle)&#13;
&#13;
    #Write the current user to ensure Impersonation worked and to remind user to revert back when finished.&#13;
    if (!$Quiet) {&#13;
        Write-Host "You are now impersonating user $([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)"&#13;
        Write-Host "It is very important that you call Remove-ImpersonateUser when finished to revert back to your user." `&#13;
            -ForegroundColor DarkYellow -BackgroundColor Black&#13;
    }&#13;
}&#13;
&#13;
#Clean up sensitive variables&#13;
$Username = $Domain = $Password = $Credential = $null&#13;
}&#13;
&#13;
#Function put in the Global scope to be used when Impersonation is finished.&#13;
Function Global:Remove-ImpersonateUser {&#13;
    &lt;#&#13;
    .SYNOPSIS&#13;
    Used to revert back to the orginal user after New-ImpersonateUser is called. You can only call this function once; it is deleted after it runs.&#13;
&#13;
    .INPUTS&#13;
    None.  You cannot pipe objects to Remove-ImpersonateUser&#13;
&#13;
    .OUTPUTS&#13;
    None.  Remove-ImpersonateUser does not generate any output.&#13;
    #&gt;&#13;
&#13;
    #Calling the Undo method reverts back to the original user.&#13;
    $ImpersonatedUser.ImpersonationContext.Undo()&#13;
&#13;
    #Clean up the Global variable and the function itself.&#13;
    Remove-Variable ImpersonatedUser -Scope Global&#13;
    Remove-Item Function:\Remove-ImpersonateUser&#13;
}&#13;
&#13;
#endregion Impersonation&#13;
&#13;
#region Parsing Functions&#13;
	function formatSansData($sanDataArray){&#13;
		$sansData = ''&#13;
		foreach($element in $sanDataArray) {&#13;
			$sansData += $element.replace('DNS:','') + [System.Environment]::NewLine&#13;
		}&#13;
		return $sansData&#13;
	}&#13;
	&#13;
	function formatExtendedKeyData($extendedKeyDataArray){&#13;
		$extendedKeyData = ''&#13;
		foreach($element in $extendedKeyDataArray){&#13;
			$extendedKeyData += $element -replace 'Purpose..:',''  &#13;
			$extendedKeyData += [System.Environment]::NewLine&#13;
		}&#13;
		return $extendedKeyData&#13;
	}&#13;
	&#13;
	function getCommonDataElement($element,$dataArray){&#13;
		$elementResult = ''&#13;
		$elementFullName = $element + ':*'&#13;
		$elementIndex = $dataArray.indexOf(($dataArray -like $elementFullName)[0])&#13;
		if($elementIndex -ne -1){&#13;
			$elementResult = ($dataArray[$elementIndex]) -replace $element + ':',''&#13;
		}&#13;
		&#13;
		return $elementResult&#13;
	}&#13;
#endregion Parsing Functions&#13;
&#13;
#region initalize internal vars&#13;
$errorOccured 					= $false;&#13;
$errorString					= "";&#13;
$errorCode                      = 0;&#13;
&#13;
#endregion initalize internal vars&#13;
&#13;
#region system variables for extended error reporting&#13;
&#13;
$ReportErrorShowExceptionClass	= 1;&#13;
$ReportErrorShowInnerException	= 1;&#13;
$ReportErrorShowSource 			= 1;&#13;
$ReportErrorShowStackTrace 		= 1;&#13;
#system variable must be set to stop to catch &#13;
#external invoke errors.&#13;
$ErrorActionPreference 			= "stop";&#13;
&#13;
#endregion system variables for extended error reporting&#13;
&#13;
try {&#13;
&#13;
	Set-Impersonation -Username $Username -Domain $userDomain -Password $userPass -Quiet&#13;
&#13;
	$scanFileCsv = Import-Csv -Path $fileInputFullPath ;&#13;
&#13;
	$scanArray = @();&#13;
	$counter = 0&#13;
	&#13;
	foreach($row in $scanFileCsv){&#13;
		$ipAddress = $row.IPAddress&#13;
        $dnsEntry = $row.DNSName&#13;
        $netBios = $row.DNSName&#13;
		$firstDetected = ''&#13;
		$lastDetected = $row.LastDetected.Replace(',','')&#13;
		$convertedDateTime = [datetime]::ParseExact($lastDetected,"MMM d yyyy HH:mm:ss UTC",[system.globalization.cultureinfo]::InvariantCulture)&#13;
		&#13;
		$lastDetectedString = "{0:MM/dd/yyyy hh:mm:sstt}" -f $convertedDateTime &#13;
		&#13;
		$certResult = $row.CertificateDetail&#13;
#		$certLines = $certResult.Split([System.Environment]::NewLine,[System.StringSplitOptions]::RemoveEmptyEntries)&#13;
 		$certLines = $certResult.Split([System.Environment]::NewLine)&#13;
       	$certLineCount = $certLines.Count&#13;
		$lastLine = $certLines[$certLineCount-1]&#13;
		&#13;
		#find sans data&#13;
		$sans = ''&#13;
		$sanIndex = $certLines.IndexOf('Extension: Subject Alternative Name (2.5.29.17)')&#13;
		if($sanIndex -gt -1) {&#13;
			$subArray = $certLines[$sanIndex..$certLineCount]&#13;
			$sanIndexEnd = $subArray.IndexOf("")&#13;
			$sanDataArray = $subArray[2..($sanIndexEnd - 1)]&#13;
			$sans = formatSansData $sanDataArray&#13;
		}&#13;
&#13;
		#find serial number&#13;
		$serialNumber = ''&#13;
		$serialNumberIndex = $certLines.IndexOf(($certLines -like 'Serial Number:*')[0]);&#13;
		if($serialNumberIndex){&#13;
			$serialNumber = (($certLines[$serialNumberIndex]).replace('Serial Number:','')).replace(' ','')&#13;
		}&#13;
		&#13;
		#find Signature Algorithm&#13;
		$signatureAlgorithm = ''&#13;
		$signatureAlgorithmIndex = $certLines.IndexOf(($certLines -like 'Signature Algorithm:*')[0]);&#13;
		if($signatureAlgorithmIndex){&#13;
			$signatureAlgorithm = ($certLines[$signatureAlgorithmIndex]).replace('Signature Algorithm:','')&#13;
		}&#13;
		&#13;
		#find issuerOrganizationName and issuerCommonName&#13;
		$issuerOrganizationName = ''&#13;
		$issuerCommonName = ''&#13;
		$issuerNameIndex = $certLines.IndexOf(($certLines -like 'Issuer Name:*')[0]);&#13;
		if($issuerNameIndex -gt -1){&#13;
			$subIssuerArray = $certLines[($issuerNameIndex + 2)..$certLineCount]&#13;
			$issuerNameIndexEnd = $subIssuerArray.IndexOf("")&#13;
			$issuerDataArray = $subIssuerArray[0..($issuerNameIndexEnd - 1)]&#13;
			$issuerOrganizationName = getCommonDataElement -element 'Organization' -dataArray $issuerDataArray&#13;
			$issuerCommonName = getCommonDataElement -element 'Common Name' -dataArray $issuerDataArray&#13;
		}&#13;
		&#13;
		#find subjectOrganizationName and subjectCommonName&#13;
		$subjectOrganizationName = ''&#13;
		$subjectCommonName = ''&#13;
		$subjectNameIndex = $certLines.IndexOf(($certLines -like 'Plugin Output: Subject Name: *')[0]);&#13;
		if($subjectNameIndex -gt -1){&#13;
			$subSubjectArray = $certLines[($subjectNameIndex + 2)..$certLineCount]&#13;
			$subjectNameIndexEnd = $subSubjectArray.IndexOf("")&#13;
			$subjectDataArray = $subSubjectArray[0..($subjectNameIndexEnd - 1)]&#13;
			$subjectOrganizationName = getCommonDataElement -element 'Organization' -dataArray $subjectDataArray&#13;
			$subjectCommonName = getCommonDataElement -element 'Common Name' -dataArray $subjectDataArray&#13;
		}&#13;
		#find certificate date range&#13;
		$validFrom = ''&#13;
		$validFromIndex = $certLines.IndexOf(($certLines -like 'Not Valid Before:*')[0]);&#13;
		if($validFromIndex -gt -1){&#13;
			$validFrom = ($certLines[$validFromIndex]).replace('Not Valid Before:','')&#13;
		}&#13;
		$validTo = ''&#13;
		$validToIndex = $certLines.IndexOf(($certLines -like 'Not Valid After:*')[0]);&#13;
		if($validToIndex -gt -1){&#13;
			$validTo = ($certLines[$validToIndex]).replace('Not Valid After:','')&#13;
		}	&#13;
		&#13;
		#find ExtendedKeyUsage&#13;
		$extendedKeyUsage = ''&#13;
		$extendedKeyIndex = $certLines.IndexOf('Extension: Extended Key Usage (2.5.29.37)');&#13;
		if($extendedKeyIndex -gt -1){&#13;
			$subExtendedKeyArray = $certLines[$extendedKeyIndex..$certLineCount]&#13;
			$extendedKeyIndexEnd = $subExtendedKeyArray.IndexOf("")&#13;
			$extendedKeyDataArray = $subExtendedKeyArray[2..($extendedKeyIndexEnd - 1)]&#13;
			&#13;
			$extendedKeyUsage = formatExtendedKeyData $extendedKeyDataArray&#13;
		}&#13;
		&#13;
		$counter += 1&#13;
		&#13;
        $scannedCertificate = New-Object -TypeName PSCustomObject &#13;
		&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "RowID" -Value $counter -Force&#13;
        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "ipAddress" -Value $ipAddress -Force&#13;
        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "dnsEntry" -Value $dnsEntry -Force&#13;
        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "netBios" -Value $netBios -Force&#13;
        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "firstDetected" -Value $firstDetected -Force&#13;
        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "lastDetected" -Value $lastDetectedString -Force&#13;
    	$scannedCertificate | Add-Member -MemberType NoteProperty -Name "serialNumber" -Value $serialNumber -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "signatureAlgorithm" -Value $signatureAlgorithm -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "issuerOrganizationName" -Value $issuerOrganizationName -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "subjectOrganizationName" -Value $subjectOrganizationName -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "issuerCommonName" -Value $issuerCommonName -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "subjectCommonName" -Value $subjectCommonName -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "validFrom" -Value $validFrom -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "validTo" -Value $validTo -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "ExtendedKeyUsage" -Value $extendedKeyUsage -Force&#13;
		$scannedCertificate | Add-Member -MemberType NoteProperty -Name "SANs" -Value $sans -Force	&#13;
		&#13;
		&#13;
		$scanArray += $scannedCertificate&#13;
		&#13;
	}&#13;
	&#13;
    $certificatesScansObject = New-Object PSCustomObject &#13;
    $certificatesScansObject | Add-Member -type NoteProperty -Name certificateScans -Value $scanArray&#13;
    &#13;
    $jsonCertificateScan = $certificatesScansObject | ConvertTo-Json &#13;
    $jsonCertificateScan = $jsonCertificateScan | ConvertTo-Json -Compress&#13;
}&#13;
	catch [System.Management.Automation.ActionPreferenceStopException]&#13;
	{&#13;
		$errorOccured = $true;&#13;
		$errorString = $error[0].Exception.Message;&#13;
		$errorCode = -1&#13;
	}&#13;
	catch [System.Exception]&#13;
	{&#13;
		$errorOccured = $true;&#13;
		$errorString = $error[0].Exception.Message;&#13;
		$errorCode = -1&#13;
&#13;
	}&#13;
	finally &#13;
	{&#13;
		if ($errorOccured -eq $true)&#13;
		{&#13;
    		SNCLog-DebugInfo "`t Failed to Parse File $fileInputFullPath : $error"&#13;
    		[Console]::Error.WriteLine("The operation failed: " + $errorString);&#13;
			Write-Host $errorString&#13;
		}&#13;
		else&#13;
		{&#13;
			Write-Host $jsonCertificateScan&#13;
		}&#13;
		&#13;
		if($ImpersonatedUser.ImpersonationContext)&#13;
		{&#13;
			Remove-ImpersonateUser&#13;
		}&#13;
		#region release any object references&#13;
&#13;
		&#13;
		#endregion release any object references		&#13;
	}	&#13;
</script>
        <script_attachment/>
        <source/>
        <sys_class_name>ecc_agent_script_file</sys_class_name>
        <sys_created_by>CHF03</sys_created_by>
        <sys_created_on>2020-01-16 18:32:07</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_domain>global</sys_domain>
        <sys_id>19afe8cfdb5a4c104ff2c553059619d0</sys_id>
        <sys_mod_count>2</sys_mod_count>
        <sys_name>processTenableScanReport.ps1</sys_name>
        <sys_overrides/>
        <sys_package display_value="Certificate Management" source="x_unugr_certificat">2c9bb9a3db8cbf40d3e954f9489619dd</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Certificate Management">2c9bb9a3db8cbf40d3e954f9489619dd</sys_scope>
        <sys_update_name>ecc_agent_script_file_19afe8cfdb5a4c104ff2c553059619d0</sys_update_name>
        <sys_updated_by>system</sys_updated_by>
        <sys_updated_on>2023-06-03 04:37:02</sys_updated_on>
        <use_attachment>false</use_attachment>
        <version/>
    </ecc_agent_script_file>
</record_update>
