<?xml version="1.0" encoding="UTF-8"?><record_update sys_domain="global" table="ecc_agent_script_file">
    <ecc_agent_script_file action="INSERT_OR_UPDATE">
        <active>true</active>
        <checksum>01U+wgm7DbsyUWrHt2GCPw==</checksum>
        <description>Powershell Script consumes the Qualys Certificate Scan Report from a Directory, Processes it and returns a JSON Obect contiaining the information found in the Scan</description>
        <directory>false</directory>
        <name>getQualysScanReport.ps1</name>
        <parent display_value="PowerShell">ef89e4fc372001006b882d465abe5d60</parent>
        <script> 	#######################################################################################################################&#13;
	###																																																							&#13;
	### 	getQualysScanReport.ps1																						&#13;
	###		version 1.1																										&#13;
	### 	script gets the Qualys Scan Report from a directory, parses it and creates a JSON object to return			&#13;
	### 	the data to a ServiceNow workflow.																		&#13;
	###																													&#13;
	### 	Gary L Fry 04-17-2019																						&#13;
	###																													&#13;
	### 	Revision History:		&#13;
	###																													&#13;
	###		1.1 04-18-2019 - GLF - Changed JSON outout to compressed output and added Extended Key Usage information																											&#13;
	###		1.2 05-14-2019 - GLF - Pulled out file manipulation into seperate process.  Qualys File is too large to process&#13;
	###                      as one file.  &#13;
	###						 Changed First Detected is blank when firt time cert is encounterd.  Populate with Last Detected&#13;
	###					     when it is blank&#13;
	###																													&#13;
	#######################################################################################################################&#13;
	&#13;
	#region input variables&#13;
	if (Test-Path env:\SNC_fileInputPath) {&#13;
		$fileInputFullPath = $env:SNC_fileInputFullPath&#13;
		$userName = $env:SNC_userName&#13;
		$userDomain = $env:SNC_userDomain&#13;
		$userPass = $env:SNC_userPass&#13;
		}        &#13;
    #endregion&#13;
&#13;
function Set-Impersonation&#13;
{&#13;
	Param(&#13;
	    [Parameter(ParameterSetName="ClearText", Mandatory=$true)][string]$Username,&#13;
	    [Parameter(ParameterSetName="ClearText", Mandatory=$true)][string]$Domain,&#13;
	    [Parameter(ParameterSetName="ClearText", Mandatory=$true)][string]$Password,&#13;
	    [Parameter(ParameterSetName="Credential", Mandatory=$true, Position=0)][PSCredential]$Credential,&#13;
	    [Parameter()][Switch]$Quiet&#13;
	)&#13;
&#13;
#Import the LogonUser Function from advapi32.dll and the CloseHandle Function from kernel32.dll&#13;
Add-Type -Namespace Import -Name Win32 -MemberDefinition @'&#13;
    [DllImport("advapi32.dll", SetLastError = true)]&#13;
    public static extern bool LogonUser(string user, string domain, string password, int logonType, int logonProvider, out IntPtr token);&#13;
&#13;
    [DllImport("kernel32.dll", SetLastError = true)]&#13;
    public static extern bool CloseHandle(IntPtr handle);&#13;
'@&#13;
&#13;
#Set Global variable to hold the Impersonation after it is created so it may be ended after script run&#13;
$Global:ImpersonatedUser = @{}&#13;
#Initialize handle variable so that it exists to be referenced in the LogonUser method&#13;
$tokenHandle = 0&#13;
&#13;
#Pass the PSCredentials to the variables to be sent to the LogonUser method&#13;
if ($Credential) {&#13;
    Get-Variable Username, Domain, Password | ForEach-Object {&#13;
        Set-Variable $_.Name -Value $Credential.GetNetworkCredential().$($_.Name)}&#13;
}&#13;
&#13;
#Call LogonUser and store its success.  [ref]$tokenHandle is used to store the token "out IntPtr token" from LogonUser.&#13;
$returnValue = [Import.Win32]::LogonUser($Username, $Domain, $Password, 2, 0, [ref]$tokenHandle)&#13;
&#13;
#If it fails, throw the verbose with the error code&#13;
if (!$returnValue) {&#13;
    $errCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error();&#13;
	if (!$Quiet) {&#13;
    	Write-Host "Impersonate-User failed a call to LogonUser with error code: $errCode"&#13;
	}&#13;
    throw [System.ComponentModel.Win32Exception]$errCode&#13;
}&#13;
#Successful token stored in $tokenHandle&#13;
else {&#13;
    #Call the Impersonate method with the returned token. An ImpersonationContext is returned and stored in the&#13;
    #Global variable so that it may be used after script run.&#13;
    $Global:ImpersonatedUser.ImpersonationContext = [System.Security.Principal.WindowsIdentity]::Impersonate($tokenHandle)&#13;
    &#13;
    #Close the handle to the token. Voided to mask the Boolean return value.&#13;
    [void][Import.Win32]::CloseHandle($tokenHandle)&#13;
&#13;
    #Write the current user to ensure Impersonation worked and to remind user to revert back when finished.&#13;
    if (!$Quiet) {&#13;
        Write-Host "You are now impersonating user $([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)"&#13;
        Write-Host "It is very important that you call Remove-ImpersonateUser when finished to revert back to your user." `&#13;
            -ForegroundColor DarkYellow -BackgroundColor Black&#13;
    }&#13;
}&#13;
&#13;
#Clean up sensitive variables&#13;
$Username = $Domain = $Password = $Credential = $null&#13;
}&#13;
&#13;
#Function put in the Global scope to be used when Impersonation is finished.&#13;
Function Global:Remove-ImpersonateUser {&#13;
    &lt;#&#13;
    .SYNOPSIS&#13;
    Used to revert back to the orginal user after New-ImpersonateUser is called. You can only call this function once; it is deleted after it runs.&#13;
&#13;
    .INPUTS&#13;
    None.  You cannot pipe objects to Remove-ImpersonateUser&#13;
&#13;
    .OUTPUTS&#13;
    None.  Remove-ImpersonateUser does not generate any output.&#13;
    #&gt;&#13;
&#13;
    #Calling the Undo method reverts back to the original user.&#13;
    $ImpersonatedUser.ImpersonationContext.Undo()&#13;
&#13;
    #Clean up the Global variable and the function itself.&#13;
    Remove-Variable ImpersonatedUser -Scope Global&#13;
    Remove-Item Function:\Remove-ImpersonateUser&#13;
}&#13;
&#13;
	#region initalize internal vars&#13;
	$errorOccured 					= $false;&#13;
    $errorString					= "";&#13;
    $errorCode                      = 0;&#13;
	&#13;
	#endregion initalize internal vars&#13;
	&#13;
	#region system variables for extended error reporting&#13;
&#13;
	$ReportErrorShowExceptionClass	= 1;&#13;
	$ReportErrorShowInnerException	= 1;&#13;
	$ReportErrorShowSource 			= 1;&#13;
	$ReportErrorShowStackTrace 		= 1;&#13;
	#system variable must be set to stop to catch &#13;
	#external invoke errors.&#13;
	$ErrorActionPreference 			= "stop";&#13;
&#13;
	#endregion system variables for extended error reporting&#13;
&#13;
	#region main try&#13;
    try {&#13;
 &#13;
		Set-Impersonation -Username $Username -Domain $userDomain -Password $userPass -Quiet&#13;
&#13;
&#13;
        $scanFileCsv = Import-Csv -Path $fileInputFullPath ;&#13;
&#13;
        #init the array&#13;
        $scanArray = @();&#13;
 		$counter = 0&#13;
		&#13;
        foreach($row in $scanFileCsv){&#13;
            $ipAddress = $row.IP;&#13;
            $dnsEntry = $row.DNS;&#13;
            $netBios = $row.NetBIOS;&#13;
			if(($row.'"First Detected"').length -gt 0)&#13;
			{&#13;
            	$firstDetected = $row.'"First Detected"'&#13;
			} &#13;
			else&#13;
			{&#13;
				$firstDetected = $row.'"Last Detected"';&#13;
			}&#13;
            $lastDetected = $row.'"Last Detected"'&#13;
			&#13;
 &#13;
            $certResult = $row.Results;&#13;
	&#13;
            $certLines = $certResult.Split([System.Environment]::NewLine,[System.StringSplitOptions]::RemoveEmptyEntries)&#13;
            $certLineCount = $certLines.Count&#13;
            $lastLine = $certLines[$certLineCount-1]&#13;
            $numberOfCerts = ($lastLine.Substring(0,3)).Replace("(","").Replace(")","")&#13;
            [int]$numberOfCerts += 1&#13;
            &#13;
            $newCertificate = $false;&#13;
            $issuerName = $false;&#13;
            $subjectName = $false;&#13;
           &#13;
            foreach($certLine in $certLines)&#13;
            {&#13;
                $valuePair = $certLine.Split("`t",[System.StringSplitOptions]::RemoveEmptyEntries) &#13;
                if($valuePair[0] -like "(*)Certificate*" )&#13;
                {&#13;
                    if($newCertificate -eq $false)&#13;
                    {&#13;
						&#13;
                        $scannedCertificate = New-Object -TypeName PSCustomObject &#13;
        				&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "RowID" -Value $counter -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "ipAddress" -Value $ipAddress -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "dnsEntry" -Value $dnsEntry -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "netBios" -Value $netBios -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "firstDetected" -Value $firstDetected -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "lastDetected" -Value $lastDetected -Force&#13;
                    	$scannedCertificate | Add-Member -MemberType NoteProperty -Name "serialNumber" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "signatureAlgorithm" -Value "" -Force&#13;
  						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "issuerOrganizationName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "subjectOrganizationName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "issuerCommonName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "subjectCommonName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "validFrom" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "validTo" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "ExtendedKeyUsage" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "SANs" -Value "" -Force&#13;
						&#13;
						$newCertificate = $true&#13;
                    }&#13;
                    else&#13;
                    {&#13;
                        $scanArray += $scannedCertificate&#13;
						$counter += 1&#13;
                        $newCertificate = $false&#13;
                        $scannedCertificate = New-Object -TypeName PSCustomObject &#13;
        &#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "RowID" -Value $counter -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "ipAddress" -Value $ipAddress -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "dnsEntry" -Value $dnsEntry -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "netBios" -Value $netBios -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "firstDetected" -Value $firstDetected -Force&#13;
                        $scannedCertificate | Add-Member -MemberType NoteProperty -Name "lastDetected" -Value $lastDetected -Force&#13;
                    	$scannedCertificate | Add-Member -MemberType NoteProperty -Name "serialNumber" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "signatureAlgorithm" -Value "" -Force&#13;
  						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "issuerOrganizationName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "subjectOrganizationName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "issuerCommonName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "subjectCommonName" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "validFrom" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "validTo" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "ExtendedKeyUsage" -Value "" -Force&#13;
						$scannedCertificate | Add-Member -MemberType NoteProperty -Name "SANs" -Value "" -Force&#13;
                    	&#13;
                    }&#13;
                    &#13;
                }&#13;
                if($valuePair[0] -like "(*)Serial Number*")&#13;
                {&#13;
                    $serialNumber = ($valuePair[1]).Replace(":","")&#13;
                    $scannedCertificate.serialNumber = $serialNumber&#13;
                }&#13;
                if($valuePair[0] -like "(*)Signature Algorithm*")&#13;
                {&#13;
                    $signatureAlgorithm = $valuePair[1]&#13;
                    $scannedCertificate.signatureAlgorithm = $signatureAlgorithm&#13;
                }&#13;
                if($valuePair[0] -like "(*)ISSUER NAME*")&#13;
                {&#13;
                    $issuerName = $true&#13;
                    $subjectName = $false&#13;
                }&#13;
                if($valuePair[0] -like "(*)SUBJECT NAME*")&#13;
                {&#13;
                    $issuerName = $false&#13;
                    $subjectName = $true&#13;
                }&#13;
                &#13;
                if(($valuePair[0] -like "organizationName*" -or $valuePair[0] -like "*organizationName*" )-and $issuerName)&#13;
                {&#13;
                    $issuerOrganizationName = $valuePair[1]&#13;
                    $scannedCertificate.issuerOrganizationName = $issuerOrganizationName&#13;
                }&#13;
                if(($valuePair[0] -like "organizationName*" -or $valuePair[0] -like "*organizationName*"  ) -and $subjectName)&#13;
                {&#13;
                    $subjectOrganizationName = $valuePair[1]&#13;
                    $scannedCertificate.subjectOrganizationName = $subjectOrganizationName&#13;
                }&#13;
                if(($valuePair[0] -like "commonName*" -or $valuePair[0] -like "*commonName*"  ) -and $issuerName)&#13;
                {&#13;
                    $issuerCommonName = $valuePair[1]&#13;
                    $scannedCertificate.issuerCommonName = $issuerCommonName&#13;
                }&#13;
                if(($valuePair[0] -like "commonName*" -or $valuePair[0] -like "*commonName*" ) -and $subjectName)&#13;
                {&#13;
                    $subjectCommonName = $valuePair[1]&#13;
                    $scannedCertificate.subjectCommonName = $subjectCommonName&#13;
                }&#13;
                if($valuePair[0] -like "(*)Valid From*")&#13;
                {&#13;
                    $validFrom = $valuePair[1]&#13;
                    $scannedCertificate.validFrom = $validFrom&#13;
                }&#13;
                if($valuePair[0] -like "(*)Valid Till*")&#13;
                {&#13;
                    $validTo = $valuePair[1]&#13;
                    $scannedCertificate.validTo = $validTo&#13;
                }&#13;
                if($valuePair[0] -like "*Subject Alternative Name*")&#13;
                {&#13;
                    $Sans =""&#13;
                    $subjectAlternativeNames = ($valuePair[1]).Replace("DNS:","")&#13;
                    $subjectAlternativeArray = $subjectAlternativeNames.Split(",")&#13;
                    foreach($name in $subjectAlternativeArray)&#13;
                    {&#13;
                        $sans += $name + [System.Environment]::NewLine&#13;
                    }&#13;
                    $scannedCertificate.SANs = $sans&#13;
                }&#13;
&#13;
                if($valuePair[0] -like "(*)*Extended Key Usage*")&#13;
                {&#13;
                    $ExtendedKeyUsage = $valuePair[1]&#13;
                    $scannedCertificate.ExtendedKeyUsage = $ExtendedKeyUsage&#13;
                }&#13;
                &#13;
            }&#13;
            &#13;
            if($newCertificate -eq $true)&#13;
            {&#13;
                $scanArray += $scannedCertificate&#13;
				$counter += 1;&#13;
            }&#13;
        }&#13;
&#13;
        $certificatesScansObject = New-Object PSCustomObject &#13;
        $certificatesScansObject | Add-Member -type NoteProperty -Name certificateScans -Value $scanArray&#13;
        &#13;
        $jsonCertificateScan = $certificatesScansObject | ConvertTo-Json &#13;
        $jsonCertificateScan = $jsonCertificateScan | ConvertTo-Json -Compress&#13;
        &#13;
    }&#13;
	#endregion main try&#13;
	catch [System.Management.Automation.ActionPreferenceStopException]&#13;
	{&#13;
		$errorOccured = $true;&#13;
		$errorString = $error[0].Exception.Message;&#13;
		$errorCode = -1&#13;
	}&#13;
	catch [System.Exception]&#13;
	{&#13;
		$errorOccured = $true;&#13;
		$errorString = $error[0].Exception.Message;&#13;
		$errorCode = -1&#13;
&#13;
	}&#13;
	finally &#13;
	{&#13;
		if ($errorOccured -eq $true)&#13;
		{&#13;
    		SNCLog-DebugInfo "`t Failed to Parse File $fileInputFullPath : $error"&#13;
    		[Console]::Error.WriteLine("The operation failed: " + $errorString);&#13;
			Write-Host $errorString&#13;
		}&#13;
		else&#13;
		{&#13;
			Write-Host $jsonCertificateScan&#13;
		}&#13;
		&#13;
		if($ImpersonatedUser.ImpersonationContext)&#13;
		{&#13;
			Remove-ImpersonateUser&#13;
		}&#13;
		#region release any object references&#13;
&#13;
		&#13;
		#endregion release any object references		&#13;
	}	&#13;
</script>
        <script_attachment/>
        <source/>
        <sys_class_name>ecc_agent_script_file</sys_class_name>
        <sys_created_by>CHF03</sys_created_by>
        <sys_created_on>2019-04-17 19:50:21</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_domain>global</sys_domain>
        <sys_id>886c317edbb43f80d3e954f94896190f</sys_id>
        <sys_mod_count>23</sys_mod_count>
        <sys_name>getQualysScanReport.ps1</sys_name>
        <sys_overrides/>
        <sys_package display_value="Certificate Management" source="x_unugr_certificat">2c9bb9a3db8cbf40d3e954f9489619dd</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Certificate Management">2c9bb9a3db8cbf40d3e954f9489619dd</sys_scope>
        <sys_update_name>ecc_agent_script_file_886c317edbb43f80d3e954f94896190f</sys_update_name>
        <sys_updated_by>system</sys_updated_by>
        <sys_updated_on>2023-06-03 04:37:10</sys_updated_on>
        <use_attachment>false</use_attachment>
        <version/>
    </ecc_agent_script_file>
</record_update>
