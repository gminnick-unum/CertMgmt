<?xml version="1.0" encoding="UTF-8"?><record_update sys_domain="global" table="ecc_agent_script_file">
    <ecc_agent_script_file action="INSERT_OR_UPDATE">
        <active>true</active>
        <checksum/>
        <description>Powershell script gets Certificate information from indicated CA Store.  Script Also contains functions to Impersonate a user.</description>
        <directory>false</directory>
        <name>getCACertificates.ps1</name>
        <parent display_value="PowerShell">ef89e4fc372001006b882d465abe5d60</parent>
        <script>#region input variables&#13;
	&#13;
if (Test-Path env:\SNC_certificateServer) {&#13;
    $certificateServer = $env:SNC_certificateServer&#13;
    $certificateServerDomain = $env:SNC_certificateServerDomain&#13;
    $certificateStoreName = $env:SNC_certificateStoreName&#13;
    $requestSubmissionDays = $env:SNC_requestSubmissionDays&#13;
		&#13;
    $userDomain = $env:SNC_userDomain&#13;
    $Username = $env:SNC_userName&#13;
    $userPass = $env:SNC_userPass&#13;
}&#13;
	&#13;
#endregion input variables&#13;
&#13;
#region Impersonation Functions&#13;
function Set-Impersonation {&#13;
    Param(&#13;
        [Parameter(ParameterSetName = "ClearText", Mandatory = $true)][string]$Username,&#13;
        [Parameter(ParameterSetName = "ClearText", Mandatory = $true)][string]$Domain,&#13;
        [Parameter(ParameterSetName = "ClearText", Mandatory = $true)][string]$Password,&#13;
        [Parameter(ParameterSetName = "Credential", Mandatory = $true, Position = 0)][PSCredential]$Credential,&#13;
        [Parameter()][Switch]$Quiet&#13;
    )&#13;
&#13;
    #Import the LogonUser Function from advapi32.dll and the CloseHandle Function from kernel32.dll&#13;
    Add-Type -Namespace Import -Name Win32 -MemberDefinition @'&#13;
    [DllImport("advapi32.dll", SetLastError = true)]&#13;
    public static extern bool LogonUser(string user, string domain, string password, int logonType, int logonProvider, out IntPtr token);&#13;
&#13;
    [DllImport("kernel32.dll", SetLastError = true)]&#13;
    public static extern bool CloseHandle(IntPtr handle);&#13;
'@&#13;
&#13;
    #Set Global variable to hold the Impersonation after it is created so it may be ended after script run&#13;
    $Global:ImpersonatedUser = @{}&#13;
    #Initialize handle variable so that it exists to be referenced in the LogonUser method&#13;
    $tokenHandle = 0&#13;
&#13;
    #Pass the PSCredentials to the variables to be sent to the LogonUser method&#13;
    if ($Credential) {&#13;
        Get-Variable Username, Domain, Password | ForEach-Object {&#13;
            Set-Variable $_.Name -Value $Credential.GetNetworkCredential().$($_.Name) }&#13;
    }&#13;
&#13;
    #Call LogonUser and store its success.  [ref]$tokenHandle is used to store the token "out IntPtr token" from LogonUser.&#13;
    $returnValue = [Import.Win32]::LogonUser($Username, $Domain, $Password, 2, 0, [ref]$tokenHandle)&#13;
&#13;
    #If it fails, throw the verbose with the error code&#13;
    if (!$returnValue) {&#13;
        $errCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error();&#13;
        if (!$Quiet) {&#13;
            Write-Host "Impersonate-User failed a call to LogonUser with error code: $errCode"&#13;
        }&#13;
        throw [System.ComponentModel.Win32Exception]$errCode&#13;
    }&#13;
    #Successful token stored in $tokenHandle&#13;
    else {&#13;
        #Call the Impersonate method with the returned token. An ImpersonationContext is returned and stored in the&#13;
        #Global variable so that it may be used after script run.&#13;
        $Global:ImpersonatedUser.ImpersonationContext = [System.Security.Principal.WindowsIdentity]::Impersonate($tokenHandle)&#13;
    &#13;
        #Close the handle to the token. Voided to mask the Boolean return value.&#13;
        [void][Import.Win32]::CloseHandle($tokenHandle)&#13;
&#13;
        #Write the current user to ensure Impersonation worked and to remind user to revert back when finished.&#13;
        if (!$Quiet) {&#13;
            Write-Host "You are now impersonating user $([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)"&#13;
            Write-Host "It is very important that you call Remove-ImpersonateUser when finished to revert back to your user." `&#13;
                -ForegroundColor DarkYellow -BackgroundColor Black&#13;
        }&#13;
    }&#13;
&#13;
    #Clean up sensitive variables&#13;
    $Username = $Domain = $Password = $Credential = $null&#13;
}&#13;
&#13;
#Function put in the Global scope to be used when Impersonation is finished.&#13;
Function Global:Remove-ImpersonateUser {&#13;
    &lt;#&#13;
    .SYNOPSIS&#13;
    Used to revert back to the orginal user after New-ImpersonateUser is called. You can only call this function once; it is deleted after it runs.&#13;
&#13;
    .INPUTS&#13;
    None.  You cannot pipe objects to Remove-ImpersonateUser&#13;
&#13;
    .OUTPUTS&#13;
    None.  Remove-ImpersonateUser does not generate any output.&#13;
    #&gt;&#13;
&#13;
    #Calling the Undo method reverts back to the original user.&#13;
    $ImpersonatedUser.ImpersonationContext.Undo()&#13;
&#13;
    #Clean up the Global variable and the function itself.&#13;
    Remove-Variable ImpersonatedUser -Scope Global&#13;
    Remove-Item Function:\Remove-ImpersonateUser&#13;
}&#13;
#endregion Impersonation Functions	&#13;
	&#13;
	&#13;
&#13;
	&#13;
#region initalize internal vars&#13;
$errorOccured = $false;&#13;
$errorString = "";&#13;
	&#13;
#endregion initalize internal vars&#13;
	&#13;
#region system variables for extended error reporting&#13;
&#13;
$ReportErrorShowExceptionClass	= 1;&#13;
$ReportErrorShowInnerException	= 1;&#13;
$ReportErrorShowSource = 1;&#13;
$ReportErrorShowStackTrace = 1;&#13;
#system variable must be set to stop to catch &#13;
#external invoke errors.&#13;
$ErrorActionPreference = "stop";&#13;
&#13;
#endregion system variables for extended error reporting&#13;
&#13;
try {&#13;
    Set-Impersonation -Username $Username -Domain $userDomain -Password $userPass -Quiet&#13;
		&#13;
    $certificateStore = $certificateServer + "." + $certificateServerDomain + "\" + $certificateStoreName&#13;
    #initialize the certificate array&#13;
    $certificateArray = @()&#13;
&#13;
    #create the &#13;
    $certificateView = New-Object -ComObject CertificateAuthority.View&#13;
    $null = $certificateView.OpenConnection($certificateStore)&#13;
&#13;
    [String[]] | Out-Null&#13;
    $properties = (   'Issued Common Name', &#13;
        'Serial Number', &#13;
        'Certificate Expiration Date', &#13;
        'Certificate Effective Date', &#13;
        'Issued Distinguished Name',&#13;
        'Issued Domain Component',&#13;
        'Issued Email Address',&#13;
        'Issued Request ID', &#13;
        'Request ID',&#13;
        'Issued Organization', &#13;
        'Issued Organization Unit', &#13;
        'Request Submission Date',&#13;
        'Request Disposition',&#13;
        'Request Disposition Message',&#13;
        'Request Email Address',&#13;
        'Requester Name', &#13;
        'Request Organization',&#13;
        'Request Organization Unit',&#13;
        'User Principal Name',&#13;
        'Revocation Date',&#13;
        'Binary Certificate') &#13;
						&#13;
    $certificateView.SetResultColumnCount($properties.Count)&#13;
&#13;
    foreach ($item in $properties) {&#13;
        $index = $certificateView.GetColumnIndex($false, $item)&#13;
        $certificateView.SetResultColumn($index)&#13;
    }&#13;
			&#13;
    #region seek filters&#13;
			&#13;
    $CVR_SEEK_EQ = 1&#13;
    $CVR_SEEK_LT = 2&#13;
    $CVR_SEEK_GE = 8&#13;
    $CVR_SEEK_GT = 16&#13;
			&#13;
    #endregion seek filters&#13;
&#13;
    #			$index = $certificateView.GetColumnIndex($false, 'Certificate Expiration Date')&#13;
    #	        $now = Get-Date&#13;
    #	        $expirationdate = $now.AddDays($expiringInDays)&#13;
    #&#13;
    #	#        $certificateView.SetRestriction($index,$CVR_SEEK_LT,0,$now)&#13;
    #	        $certificateView.SetRestriction($index,$CVR_SEEK_GT,0,$expirationdate)&#13;
			&#13;
    #region restrictions&#13;
			&#13;
    #restrict to retrieving only issued certificates&#13;
    # 20 - issued certificates&#13;
    $certificateView.SetRestriction($certificateView.GetColumnIndex($false, 'Request Disposition'), $CVR_SEEK_EQ, 0, 20)&#13;
			&#13;
    #Restrict to Request Submission Date greater than day&#13;
    if ($requestSubmissionDays) {&#13;
        $index = $certificateView.GetColumnIndex($false, 'Certificate Expiration Date')&#13;
        $seekFromDate = (Get-Date).AddDays(-$requestSubmissionDays) &#13;
				&#13;
        $certificateView.SetRestriction($index, $CVR_SEEK_GE, 0, $seekFromDate)&#13;
			&#13;
    }&#13;
			&#13;
    #endregion restrictions&#13;
&#13;
    $CV_OUT_BASE64HEADER = 0 &#13;
    $CV_OUT_BASE64 = 1 &#13;
    $rowObject = $certificateView.OpenView() &#13;
&#13;
    while ($rowObject.Next() -ne -1) {&#13;
        $certificate = New-Object -TypeName PSCustomObject &#13;
        $columnObject = $rowObject.EnumCertViewColumn()&#13;
        $null = $columnObject.Next()&#13;
        do {&#13;
            $displayName = $columnObject.GetDisplayName()&#13;
            # format Binary Certificate in a savable format.&#13;
            if ($displayName -eq 'Binary Certificate') {&#13;
                $certificate | Add-Member -MemberType NoteProperty -Name $displayName -Value $($columnObject.GetValue($CV_OUT_BASE64HEADER)) -Force&#13;
                $rawCertificate = $($columnObject.GetValue(1))&#13;
            } else {&#13;
                $certificate | Add-Member -MemberType NoteProperty -Name $displayName -Value $($columnObject.GetValue($CV_OUT_BASE64)) -Force&#13;
            }&#13;
        }&#13;
        until ($columnObject.Next() -eq -1)&#13;
        Clear-Variable -Name columnObject&#13;
				&#13;
        #region get subject alternative name&#13;
				&#13;
        $utf8Encoding = New-Object System.Text.UTF8Encoding&#13;
        [byte[]] $byteArray = $utf8Encoding.GetBytes($rawCertificate)	&#13;
        $ErrorActionPreference = "SilentlyContinue"&#13;
        $x509Certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2((, $byteArray))&#13;
        $subjectAlternativeNames = ""&#13;
        $subjectAlternativeNames = ($x509Certificate.Extensions | Where-Object { $_.Oid.FriendlyName -eq "subject alternative name" })&#13;
        if ($subjectAlternativeNames) {&#13;
            $saName = $subjectAlternativeNames.Format(1)&#13;
					&#13;
            #					switch -wildcard ($saName)&#13;
            #					{&#13;
            #	    				"other name*" {$saName.Substring(17)} &#13;
            #    					"dns name*" {$saName} 				&#13;
            #					}&#13;
        } else {&#13;
            $saName = ""&#13;
        }&#13;
&#13;
        $certificate | Add-Member -MemberType NoteProperty "DNSSubjectAlternativeNames" -Value $saName -Force				&#13;
&#13;
        $certTemplateName = ($x509Certificate.Extensions | ? { $_.Oid.FriendlyName -match 'Template' })&#13;
&#13;
        $certificateTemplateName = ""&#13;
        if ($certTemplateName) {&#13;
            $certificateTemplateName = $certTemplateName.Format(0) -replace "(.+)?=(.+)\((.+)?", '$2'&#13;
            $certificate | Add-Member -MemberType NoteProperty "CertificateTemplateName" -Value $certificateTemplateName -Force&#13;
        }	&#13;
					&#13;
        $certificate | Add-Member -MemberType NoteProperty "CertificateTemplateName" -Value $certificateTemplateName -Force&#13;
&#13;
        $subject = "";&#13;
        $subject = $x509Certificate.GetNameInfo([System.Security.Cryptography.X509Certificates.X509NameType]::DnsName, $false)&#13;
        if ($subject -eq "") {&#13;
            $subject = $x509Certificate.GetNameInfo([System.Security.Cryptography.X509Certificates.X509NameType]::DnsFromAlternativeName, $false)&#13;
        }&#13;
        if ($subject -eq "") {&#13;
            $subject = $x509Certificate.Subject&#13;
        }				&#13;
&#13;
        $certificate | Add-Member -MemberType NoteProperty "Subject" -Value $subject -Force&#13;
&#13;
        $signatureAlgorithm = $x509Certificate.SignatureAlgorithm.FriendlyName;&#13;
				&#13;
        $certificate | Add-Member -MemberType NoteProperty "SignatureAlgorithm" -Value $signatureAlgorithm -Force&#13;
				&#13;
        #$x509Certificate.Dispose()&#13;
				&#13;
        Clear-Variable -Name utf8Encoding&#13;
        Clear-Variable -Name x509Certificate&#13;
        Clear-Variable -Name subjectAlternativeNames&#13;
        Clear-Variable -Name certTemplateName&#13;
			&#13;
        #endregion get subject alternative name&#13;
				&#13;
        $certificateArray += $certificate&#13;
&#13;
    }&#13;
			&#13;
    #region convert data to json object&#13;
			&#13;
    $certificatesObject = New-Object PSCustomObject &#13;
    $certificatesObject | Add-Member -type NoteProperty -Name certificates -Value $certificateArray&#13;
			&#13;
    $jsonCertificates = $certificatesObject | ConvertTo-Json &#13;
    $jsonCertificates = $jsonCertificates | ConvertTo-Json -Compress&#13;
			&#13;
    #endregion convert data to json object&#13;
		&#13;
} catch [System.Management.Automation.ActionPreferenceStopException] {&#13;
    $errorOccured = $true;&#13;
    $errorString = $error[0].Exception.Message;&#13;
    $errorCode = -1&#13;
} catch [System.Exception] {&#13;
    $errorOccured = $true;&#13;
    $errorString = $error[0].Exception.Message;&#13;
    $errorCode = -1&#13;
&#13;
} finally {&#13;
    if ($errorOccured -eq $true) {&#13;
        SNCLog-DebugInfo "`t getCACertificates on Certificate Store $certificateStore Failed : $error"&#13;
        [Console]::Error.WriteLine("The operation failed: " + $errorString);&#13;
        Write-Output $errorString&#13;
    } else {&#13;
        Write-Host $jsonCertificates&#13;
    }&#13;
		&#13;
    if ($ImpersonatedUser.ImpersonationContext) {&#13;
        Remove-ImpersonateUser&#13;
    }&#13;
    #region release com object&#13;
    if ($certificateView) {&#13;
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($certificateView) | Out-Null &#13;
        Remove-Variable certificateView&#13;
    }		&#13;
    #endregion release com object&#13;
}	&#13;
</script>
        <script_attachment/>
        <source/>
        <sys_class_name>ecc_agent_script_file</sys_class_name>
        <sys_created_by>CHF03</sys_created_by>
        <sys_created_on>2019-03-22 13:09:55</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_domain>global</sys_domain>
        <sys_id>03e86652dbd43b00d3e954f948961928</sys_id>
        <sys_mod_count>33</sys_mod_count>
        <sys_name>getCACertificates.ps1</sys_name>
        <sys_overrides/>
        <sys_package display_value="Certificate Management" source="x_unugr_certificat">2c9bb9a3db8cbf40d3e954f9489619dd</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Certificate Management">2c9bb9a3db8cbf40d3e954f9489619dd</sys_scope>
        <sys_update_name>ecc_agent_script_file_03e86652dbd43b00d3e954f948961928</sys_update_name>
        <sys_updated_by>CNI06</sys_updated_by>
        <sys_updated_on>2023-02-14 17:20:38</sys_updated_on>
        <use_attachment>false</use_attachment>
        <version/>
    </ecc_agent_script_file>
</record_update>
